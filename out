jp0
jp1
0a1,43
> 
> 
>   1: PROGRAM
>   2:   VARS
>   3:     x int
>   4:     y int
>   5:     p bool
>   6:   ENDVARS
>   7:   PROCEDURE q()
>   8:     PROCEDURE p(val p int)
>   9:       p:=3
>  10:       p:=true
>  11:     ENDPROCEDURE
>  12:     p:=3
>  13:     p(3)
>  14:     p(true)
>  15:   ENDPROCEDURE
>  16:   PROCEDURE r(ref p int)
>  17:     PROCEDURE p(val r int)
>  18:       r:=4
>  19:       r(3)
>  20:       r(p)
>  21:       r(y)
>  22:       r(x)
>  23:       p:=3
>  24:       p:=true
>  25:       p(3)
>  26:     ENDPROCEDURE
>  27:     r:=3
>  28:     r(3)
>  29:     r(p())
>  30:     r(y)
>  31:     r(x)
>  32:     p:=3
>  33:     p:=true
>  34:     p(p)
>  35:   ENDPROCEDURE
>  36:   p:=3
>  37:   p:=true
>  38:   p(3)
>  39: ENDPROGRAM
> 
> 
135,150d177
< L. 10: Assignment with incompatible types.
< L. 12: Left expression of assignment is not referenceable.
< L. 14: Parameter 1 with incompatible types.
< L. 17: Identifier p already declared.
< L. 19: Operator ( must be applied to a procedure in an instruction.
< L. 20: Operator ( must be applied to a procedure in an instruction.
< L. 21: Operator ( must be applied to a procedure in an instruction.
< L. 22: Operator ( must be applied to a procedure in an instruction.
< L. 24: Assignment with incompatible types.
< L. 25: Operator ( must be applied to a procedure in an instruction.
< L. 27: Left expression of assignment is not referenceable.
< L. 28: Parameter 1 is expected to be referenceable but it is not.
< L. 29: Operator ( must be applied to a function in an expression.
< L. 29: Parameter 1 is expected to be referenceable but it is not.
< L. 33: Assignment with incompatible types.
< L. 34: Operator ( must be applied to a procedure in an instruction.
152c179,180
< L. 38: Operator ( must be applied to a procedure in an instruction.
---
> BIG PROBLEM! No case defined for kind true
> BIG PROBLEM! No case defined for kind (
jp2
179,195c179,180
< L. 12: The number of parameters in the call do not match.
< L. 13: Identifier v is undeclared.
< L. 13: Parameter 1 is expected to be referenceable but it is not.
< L. 13: Parameter 3 with incompatible types.
< L. 14: The number of parameters in the call do not match.
< L. 15: The number of parameters in the call do not match.
< L. 16: Identifier p22 is undeclared.
< L. 19: Parameter 1 is expected to be referenceable but it is not.
< L. 20: Parameter 1 with incompatible types.
< L. 29: Assignment with incompatible types.
< L. 30: Operator + with incompatible types.
< L. 30: Operator - with incompatible types.
< L. 30: Assignment with incompatible types.
< L. 31: Operator / with incompatible types.
< L. 32: Identifier p11 is undeclared.
< L. 37: Identifier p22 is undeclared.
< There are errors: no code generated
---
> BIG PROBLEM! No case defined for kind (
> Generating code:
jp3
129,140c129,145
< L. 7: Operator not with incompatible types.
< L. 8: Operator not with incompatible types.
< L. 8: Operator > with incompatible types.
< L. 9: Operator + with incompatible types.
< L. 10: Operator > with incompatible types.
< L. 10: Assignment with incompatible types.
< L. 13: Operator not with incompatible types.
< L. 13: Operator = with incompatible types.
< L. 14: Operator + with incompatible types.
< L. 17: Operator = with incompatible types.
< L. 18: Operator > with incompatible types.
< There are errors: no code generated
---
> BIG PROBLEM! No case defined for kind if
> Generating code:
> program
>   parameters
>     static_link
>   endparameters
> 
>   variables
>     _x 4
>     _y 4
>     _b 4
>   endvariables
> 
>     stop
> endprogram
> 
> Executing code:
jp4
289,317d288
< L. 14: Operator / with incompatible types.
< L. 15: Operator ( must be applied to a procedure in an instruction.
< L. 16: Operator not with incompatible types.
< L. 17: Operator = with incompatible types.
< L. 18: Operator + with incompatible types.
< L. 18: Operator = with incompatible types.
< L. 18: Assignment with incompatible types.
< L. 20: Operator not with incompatible types.
< L. 20: Operator = with incompatible types.
< L. 21: Operator + with incompatible types.
< L. 24: Operator = with incompatible types.
< L. 25: Operator > with incompatible types.
< L. 26: Operator / with incompatible types.
< L. 30: Left expression of assignment is not referenceable.
< L. 31: Operator ( must be applied to a function in an expression.
< L. 31: The number of parameters in the call do not match.
< L. 34: Identifier i already declared.
< L. 35: Assignment with incompatible types.
< L. 36: Operator ( must be applied to a procedure in an instruction.
< L. 37: Left expression of assignment is not referenceable.
< L. 38: Operator * with incompatible types.
< L. 38: Parameter 4 with incompatible types.
< L. 40: Left expression of assignment is not referenceable.
< L. 41: Parameter 1 is expected to be referenceable but it is not.
< L. 41: Parameter 1 with incompatible types.
< L. 42: Left expression of assignment is not referenceable.
< L. 43: Parameter 1 with incompatible types.
< L. 43: Parameter 2 is expected to be referenceable but it is not.
< L. 43: Parameter 4 is expected to be referenceable but it is not.
320c291
< L. 47: Operator ( must be applied to a procedure in an instruction.
---
> BIG PROBLEM! No case defined for kind (
jp5
97,110c97
< L. 8: Return with incompatible type.
< L. 11: Operator ( must be applied to a function in an expression.
< L. 12: Operator ( must be applied to a function in an expression.
< L. 12: The number of parameters in the call do not match.
< L. 13: Parameter 1 with incompatible types.
< L. 13: Operator + with incompatible types.
< L. 13: Assignment with incompatible types.
< L. 14: Operator ( must be applied to a function in an expression.
< L. 14: Parameter 2 with incompatible types.
< L. 14: Parameter 2 with incompatible types.
< L. 14: Parameter 2 is expected to be referenceable but it is not.
< L. 14: Parameter 2 with incompatible types.
< L. 14: Assignment with incompatible types.
< There are errors: no code generated
---
> Generating code:
jp6
123,130c123,128
< L. 14: Identifier x already declared.
< L. 17: Operator struct. with incompatible types.
< L. 17: Operator + with incompatible types.
< L. 18: Assignment with incompatible types.
< L. 21: Assignment with incompatible types.
< L. 24: Operator array[] with incompatible types.
< L. 23: Operator + with incompatible types.
< L. 22: Assignment with incompatible types.
---
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind [
> L. 22: Left expression of assignment is not referenceable.
jp7
155,157c155,159
< L. 21: Operator struct. with incompatible types.
< L. 23: Assignment with incompatible types.
< L. 27: Assignment with incompatible types.
---
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind [
> L. 27: Left expression of assignment is not referenceable.
> BIG PROBLEM! No case defined for kind (
jp8
229,250c229
< L. 9: Assignment with incompatible types.
< L. 11: Parameter 1 with incompatible types.
< L. 13: Operator + with incompatible types.
< L. 13: Parameter 1 is expected to be referenceable but it is not.
< L. 13: Parameter 1 with incompatible types.
< L. 14: Parameter 1 with incompatible types.
< L. 15: Parameter 1 with incompatible types.
< L. 21: Identifier p already declared.
< L. 22: Left expression of assignment is not referenceable.
< L. 23: Parameter 1 with incompatible types.
< L. 25: Parameter 1 with incompatible types.
< L. 26: Assignment with incompatible types.
< L. 28: Assignment with incompatible types.
< L. 30: Assignment with incompatible types.
< L. 32: Operator ( must be applied to a procedure in an instruction.
< L. 34: Left expression of assignment is not referenceable.
< L. 35: Parameter 1 with incompatible types.
< L. 37: Parameter 1 with incompatible types.
< L. 38: Parameter 1 with incompatible types.
< L. 39: Assignment with incompatible types.
< L. 40: Operator ( must be applied to a procedure in an instruction.
< L. 41: Operator ( must be applied to a procedure in an instruction.
---
> BIG PROBLEM! No case defined for kind array
253,254c232,233
< L. 44: The number of parameters in the call do not match.
< L. 45: Operator ( must be applied to a function in an expression.
---
> BIG PROBLEM! No case defined for kind (
> BIG PROBLEM! No case defined for kind (
jp9
252,272c252,253
< L. 13: Left expression of assignment is not referenceable.
< L. 15: The number of parameters in the call do not match.
< L. 16: The number of parameters in the call do not match.
< L. 17: Parameter 1 with incompatible types.
< L. 18: Identifier p22 is undeclared.
< L. 21: Parameter 1 with incompatible types.
< L. 22: Parameter 1 with incompatible types.
< L. 23: The number of parameters in the call do not match.
< L. 34: Field n already defined in the struct.
< L. 38: Identifier w is undeclared.
< L. 38: Identifier p12 is undeclared.
< L. 38: Left expression of assignment is not referenceable.
< L. 39: Operator + with incompatible types.
< L. 40: Operator / with incompatible types.
< L. 42: Identifier p11 is undeclared.
< L. 44: Field x is not defined in the struct.
< L. 46: Operator + with incompatible types.
< L. 47: Assignment with incompatible types.
< L. 48: Assignment with incompatible types.
< L. 51: Identifier p22 is undeclared.
< There are errors: no code generated
---
> BIG PROBLEM! No case defined for kind (
> Generating code:
jp10
223,251c223,243
< L. 14: Field c already defined in the struct.
< L. 17: Operator not with incompatible types.
< L. 18: Operator not with incompatible types.
< L. 18: Operator > with incompatible types.
< L. 19: Operator + with incompatible types.
< L. 19: Operator = with incompatible types.
< L. 19: Operator - with incompatible types.
< L. 19: Operator or with incompatible types.
< L. 21: Operator [] with incompatible types.
< L. 21: Operator + with incompatible types.
< L. 21: Assignment with incompatible types.
< L. 24: Operator not with incompatible types.
< L. 24: Operator = with incompatible types.
< L. 24: Operator = with incompatible types.
< L. 25: Field b is not defined in the struct.
< L. 25: Operator / with incompatible types.
< L. 25: Assignment with incompatible types.
< L. 28: Operator > with incompatible types.
< L. 28: Operator = with incompatible types.
< L. 28: Operator = with incompatible types.
< L. 29: Operator > with incompatible types.
< L. 29: Assignment with incompatible types.
< L. 30: Assignment with incompatible types.
< L. 31: Operator + with incompatible types.
< L. 31: Assignment with incompatible types.
< L. 32: Assignment with incompatible types.
< L. 33: Operator array[] with incompatible types.
< L. 33: Operator struct. with incompatible types.
< There are errors: no code generated
---
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind if
> Generating code:
> program
>   parameters
>     static_link
>   endparameters
> 
>   variables
>     _x 4
>     _y 4
>     _b 12
>     _c 4
>   endvariables
> 
>     stop
> endprogram
> 
> Executing code:
jp11
201,221c201
< L. 8: Operator + with incompatible types.
< L. 15: Identifier x is undeclared.
< L. 16: Identifier x is undeclared.
< L. 18: Return with incompatible type.
< L. 29: Operator ( must be applied to a function in an expression.
< L. 30: Operator ( must be applied to a function in an expression.
< L. 30: The number of parameters in the call do not match.
< L. 31: Parameter 1 with incompatible types.
< L. 31: Operator + with incompatible types.
< L. 31: Assignment with incompatible types.
< L. 32: Operator ( must be applied to a function in an expression.
< L. 32: Parameter 2 with incompatible types.
< L. 32: Parameter 2 with incompatible types.
< L. 32: Parameter 2 is expected to be referenceable but it is not.
< L. 32: Parameter 2 with incompatible types.
< L. 32: Assignment with incompatible types.
< L. 34: Assignment with incompatible types.
< L. 35: Assignment with incompatible types.
< L. 36: Parameter 2 is expected to be referenceable but it is not.
< L. 36: Operator + with incompatible types.
< There are errors: no code generated
---
> Generating code:
jp12
273c273,275
< L. 12: Identifier x is undeclared.
---
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind [
275c277
< L. 13: Identifier x is undeclared.
---
> BIG PROBLEM! No case defined for kind [
277,278c279
< L. 14: Identifier x is undeclared.
< L. 14: Operator [] with incompatible types.
---
> BIG PROBLEM! No case defined for kind [
281,283c282,283
< L. 15: Identifier x is undeclared.
< L. 15: Operator [] with incompatible types.
< L. 16: Operator - with incompatible types.
---
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind (
284a285,286
> L. 17: Identifier p is undeclared.
> BIG PROBLEM! No case defined for kind (
286c288,289
< L. 18: Identifier x is undeclared.
---
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind (
288c291
< L. 19: Identifier x is undeclared.
---
> BIG PROBLEM! No case defined for kind [
290,296c293,296
< L. 20: Operator ( must be applied to a procedure in an instruction.
< L. 21: Operator ( must be applied to a procedure in an instruction.
< L. 21: The number of parameters in the call do not match.
< L. 22: Identifier m is undeclared.
< L. 22: Identifier x is undeclared.
< L. 22: Identifier y is undeclared.
< L. 22: Identifier a is undeclared.
---
> BIG PROBLEM! No case defined for kind (
> BIG PROBLEM! No case defined for kind (
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind [
298,299c298
< L. 23: Identifier m is undeclared.
< L. 23: Identifier a is undeclared.
---
> BIG PROBLEM! No case defined for kind [
301,302c300
< L. 24: Identifier m is undeclared.
< L. 24: Identifier a is undeclared.
---
> BIG PROBLEM! No case defined for kind [
304,306c302,303
< L. 25: Identifier x is undeclared.
< L. 25: Operator [] with incompatible types.
< L. 25: Identifier y is undeclared.
---
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind (
309,310c306
< L. 26: Identifier x is undeclared.
< L. 26: Operator struct. with incompatible types.
---
> BIG PROBLEM! No case defined for kind (
313c309
< L. 27: Identifier f is undeclared.
---
> BIG PROBLEM! No case defined for kind [
316,318c312
< L. 28: Identifier x is undeclared.
< L. 28: Operator array[] with incompatible types.
< L. 28: Operator [] with incompatible types.
---
> BIG PROBLEM! No case defined for kind [
321,323c315
< L. 29: Identifier x is undeclared.
< L. 29: Operator array[] with incompatible types.
< L. 29: Operator [] with incompatible types.
---
> BIG PROBLEM! No case defined for kind [
326c318
< L. 30: Identifier f is undeclared.
---
> BIG PROBLEM! No case defined for kind [
329,330c321
< L. 31: Identifier f is undeclared.
< L. 31: Operator struct. with incompatible types.
---
> BIG PROBLEM! No case defined for kind [
333,334c324
< L. 32: Identifier f is undeclared.
< L. 32: Operator struct. with incompatible types.
---
> BIG PROBLEM! No case defined for kind [
337c327
< L. 33: Identifier y is undeclared.
---
> BIG PROBLEM! No case defined for kind (
jp13
179,189c179,186
< L. 19: Identifier t already declared.
< L. 8: Return with incompatible type.
< L. 11: Return with incompatible type.
< L. 14: Return with incompatible type.
< L. 17: Return with incompatible type.
< L. 20: Return with incompatible type.
< L. 25: Referenceable expression required in read.
< L. 26: Referenceable expression required in read.
< L. 27: Referenceable expression required in read.
< L. 28: Basic type required in read.
< L. 31: Basic type required in writeln.
---
> BIG PROBLEM! No case defined for kind read
> BIG PROBLEM! No case defined for kind read
> BIG PROBLEM! No case defined for kind read
> BIG PROBLEM! No case defined for kind read
> BIG PROBLEM! No case defined for kind read
> BIG PROBLEM! No case defined for kind read
> BIG PROBLEM! No case defined for kind write
> BIG PROBLEM! No case defined for kind (
191,197c188,190
< L. 33: Instruction if requires a boolean condition.
< L. 34: Instruction while requires a boolean condition.
< L. 38: Instruction if requires a boolean condition.
< L. 39: Operator = with incompatible types.
< L. 43: Operator = with incompatible types.
< L. 44: The number of parameters in the call do not match.
< L. 44: Instruction while requires a boolean condition.
---
> BIG PROBLEM! No case defined for kind if
> BIG PROBLEM! No case defined for kind if
> BIG PROBLEM! No case defined for kind if
jp1~
15c15
<  13:     p(3)
---
>  13:     -p(3)
76,80c76,81
<     |      |                  |    \__intconst(3)
<     |      |                  \__(
<     |      |                  |   \__ident(p)
<     |      |                  |   \__list
<     |      |                  |          \__intconst(3)
---
>     |      |                  |    \__-
>     |      |                  |        \__intconst(3)
>     |      |                  |        \__(
>     |      |                  |            \__ident(p)
>     |      |                  |            \__list
>     |      |                  |                   \__intconst(3)
178,193d178
< L. 10: Assignment with incompatible types.
< L. 12: Left expression of assignment is not referenceable.
< L. 14: Parameter 1 with incompatible types.
< L. 17: Identifier p already declared.
< L. 19: Operator ( must be applied to a procedure in an instruction.
< L. 20: Operator ( must be applied to a procedure in an instruction.
< L. 21: Operator ( must be applied to a procedure in an instruction.
< L. 22: Operator ( must be applied to a procedure in an instruction.
< L. 24: Assignment with incompatible types.
< L. 25: Operator ( must be applied to a procedure in an instruction.
< L. 27: Left expression of assignment is not referenceable.
< L. 28: Parameter 1 is expected to be referenceable but it is not.
< L. 29: Operator ( must be applied to a function in an expression.
< L. 29: Parameter 1 is expected to be referenceable but it is not.
< L. 33: Assignment with incompatible types.
< L. 34: Operator ( must be applied to a procedure in an instruction.
195c180,181
< L. 38: Operator ( must be applied to a procedure in an instruction.
---
> BIG PROBLEM! No case defined for kind true
> BIG PROBLEM! No case defined for kind (
jp20
jp21
81a82,83
> BIG PROBLEM! No case defined for kind true
> BIG PROBLEM! No case defined for kind false
82a85,86
> BIG PROBLEM! No case defined for kind true
> BIG PROBLEM! No case defined for kind false
100d103
<     iload 1 t1
108d110
<     iload 0 t1
131c133,134
< 1
---
> 5
> 4
133d135
< 0
jp22
59a60
> BIG PROBLEM! No case defined for kind while
73,105d73
<   etiq while_1
<     load _I t0
<     iload 10 t1
<     lesi t0 t1 t0
<     fjmp t0 endwhile_1
<     load _I t0
<     iload 2 t1
<     load _I t2
<     iload 2 t3
<     divi t2 t3 t2
<     muli t1 t2 t1
<     subi t0 t1 t0
<     iload 0 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     load _I t0
<     wrii t0
<     wrln
<     ujmp endif_1
<   etiq else_1
<     iload 2 t0
<     load _I t1
<     muli t0 t1 t0
<     wrii t0
<     wrln
<   etiq endif_1
<     aload _I t0
<     load _I t1
<     iload 1 t2
<     addi t1 t2 t1
<     stor t1 t0
<     ujmp while_1
<   etiq endwhile_1
110,118d77
< 2
< 2
< 6
< 4
< 10
< 6
< 14
< 8
< 18
jp23
60,95c60,64
< Generating code:
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<     _A 80
<     _S 8
<   endvariables
< 
<     aload _S t0
<     addi t0 4 t0
<     iload 5 t1
<     stor t1 t0
<     aload _A t0
<     aload _S t1
<     addi t1 4 t1
<     load t1 t1
<     muli t1 8 t1
<     addi t0 t1 t0
<     aload _S t1
<     copy t1 t0 8
<     aload _A t0
<     iload 5 t1
<     muli t1 8 t1
<     addi t0 t1 t0
<     addi t0 4 t0
<     load t0 t0
<     wrii t0
<     wrln
<     stop
< endprogram
< 
< Executing code:
< 5
---
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind [
> L. 13: Left expression of assignment is not referenceable.
> BIG PROBLEM! No case defined for kind [
> There are errors: no code generated
jp24
100a101,103
> BIG PROBLEM! No case defined for kind true
> BIG PROBLEM! No case defined for kind false
> BIG PROBLEM! No case defined for kind if
101a105,106
> BIG PROBLEM! No case defined for kind true
> BIG PROBLEM! No case defined for kind false
120d124
<     iload 1 t1
128d131
<     iload 0 t1
130,147d132
<     load _X t0
<     iload 3 t1
<     muli t0 t1 t0
<     iload 10 t1
<     grti t0 t1 t0
<     aload _S t1
<     addi t1 4 t1
<     load t1 t1
<     land t0 t1 t0
<     fjmp t0 endif_1
<     aload _S t0
<     addi t0 0 t0
<     load _X t1
<     stor t1 t0
<     aload _S1 t0
<     aload _S t1
<     copy t1 t0 8
<   etiq endif_1
162,163c147,148
< 5
< 1
---
> 4
> 4
jp25
128a129,132
> BIG PROBLEM! No case defined for kind false
> BIG PROBLEM! No case defined for kind (
> BIG PROBLEM! No case defined for kind write
> BIG PROBLEM! No case defined for kind write
130,249d133
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<     _Y 4
<     _X 4
<   endvariables
< 
<     aload _Y t0
<     iload 3 t1
<     stor t1 t0
<     aload _X t0
<     iload 0 t1
<     stor t1 t0
<     iload 2 t0
<     iload 3 t1
<     muli t0 t1 t0
<     iload 1 t1
<     addi t0 t1 t0
<     pushparam t0
<     aload _Y t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_P0
<     killparam
<     killparam
<     killparam
<     load _Y t0
<     wrii t0
<     wris "  "
<     load _X t0
<     wrii t0
<     wrln
<     stop
< endprogram
< 
< subroutine program_P0_P1
<   parameters
<     _V1
<     _R1
<     _R2
<     static_link
<   endparameters
< 
<   variables
<     _Y1 4
<     _X1 4
<   endvariables
< 
<     load _R1 t0
<     load _V1 t1
<     stor t1 t0
<     load static_link t0
<     addi t0 offset(program_P0:_V0) t0
<     iload 10 t1
<     stor t1 t0
<     load static_link t0
<     load t0 t0
<     addi t0 offset(program:_X) t0
<     load static_link t1
<     addi t1 offset(program_P0:_V0) t1
<     load t1 t1
<     load _R2 t2
<     equi t1 t2 t1
<     load static_link t2
<     addi t2 offset(program_P0:_V0) t2
<     load t2 t2
<     load _R1 t3
<     load t3 t3
<     load static_link t4
<     addi t4 offset(program_P0:_R0) t4
<     load t4 t4
<     load t4 t4
<     addi t3 t4 t3
<     equi t2 t3 t2
<     land t1 t2 t1
<     lnot t1 t1
<     stor t1 t0
<     retu
< endsubroutine
< 
< subroutine program_P0
<   parameters
<     _V0
<     _R0
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _V0 t0
<     pushparam t0
<     load _R0 t0
<     pushparam t0
<     load _R0 t0
<     load t0 t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_P0_P1
<     killparam
<     killparam
<     killparam
<     killparam
<     load _V0 t0
<     wrii t0
<     wris "  "
<     load _R0 t0
<     load t0 t0
<     wrii t0
<     wris "  "
<     retu
< endsubroutine
< 
< Executing code:
< 10  7  7  1
jp26
106a107
> BIG PROBLEM! No case defined for kind while
108,204d108
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<     _X 4
<     _Y 4
<   endvariables
< 
<     aload _X t0
<     iload 1 t1
<     stor t1 t0
<   etiq while_1
<     load _X t0
<     iload 10 t1
<     lesi t0 t1 t0
<     fjmp t0 endwhile_1
<     load _X t0
<     pushparam t0
<     aload _Y t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_FACT
<     killparam
<     killparam
<     killparam
<     wris " El factorial de "
<     load _X t0
<     wrii t0
<     wris " es: "
<     load _Y t0
<     wrii t0
<     wris ""
<     wrln
<     aload _X t0
<     load _X t1
<     iload 1 t2
<     addi t1 t2 t1
<     stor t1 t0
<     ujmp while_1
<   etiq endwhile_1
<     stop
< endprogram
< 
< subroutine program_FACT
<   parameters
<     _X
<     _F
<     static_link
<   endparameters
< 
<   variables
<     _AUX 4
<   endvariables
< 
<     load _X t0
<     iload 1 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     load _F t0
<     iload 1 t1
<     stor t1 t0
<     ujmp endif_1
<   etiq else_1
<     load _X t0
<     iload 1 t1
<     subi t0 t1 t0
<     pushparam t0
<     aload _AUX t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_FACT
<     killparam
<     killparam
<     killparam
<     load _F t0
<     load _AUX t1
<     load _X t2
<     muli t1 t2 t1
<     stor t1 t0
<   etiq endif_1
<     retu
< endsubroutine
< 
< Executing code:
<  El factorial de 1 es: 1
<  El factorial de 2 es: 2
<  El factorial de 3 es: 6
<  El factorial de 4 es: 24
<  El factorial de 5 es: 120
<  El factorial de 6 es: 720
<  El factorial de 7 es: 5040
<  El factorial de 8 es: 40320
<  El factorial de 9 es: 362880
jp27
97a98
> BIG PROBLEM! No case defined for kind while
99,192d99
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<     _X 4
<     _Y 4
<   endvariables
< 
<     aload _X t0
<     iload 1 t1
<     stor t1 t0
<   etiq while_1
<     load _X t0
<     iload 10 t1
<     lesi t0 t1 t0
<     fjmp t0 endwhile_1
<     wris " El factorial de "
<     load _X t0
<     wrii t0
<     wris " es: "
<     pushparam 0
<     load _X t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_FACT
<     killparam
<     killparam
<     popparam t0
<     wrii t0
<     wrln
<     aload _X t0
<     load _X t1
<     iload 1 t2
<     addi t1 t2 t1
<     stor t1 t0
<     ujmp while_1
<   etiq endwhile_1
<     stop
< endprogram
< 
< subroutine program_FACT
<   parameters
<     returnvalue
<     _X
<     static_link
<   endparameters
< 
<   variables
<     _F 4
<   endvariables
< 
<     load _X t0
<     iload 1 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     aload _F t0
<     iload 1 t1
<     stor t1 t0
<     ujmp endif_1
<   etiq else_1
<     aload _F t0
<     pushparam 0
<     load _X t1
<     iload 1 t2
<     subi t1 t2 t1
<     pushparam t1
<     load static_link t1
<     pushparam t1
<     call program_FACT
<     killparam
<     killparam
<     popparam t1
<     load _X t2
<     muli t1 t2 t1
<     stor t1 t0
<   etiq endif_1
<     load _F t0
<     stor t0 returnvalue
<     retu
< endsubroutine
< 
< Executing code:
<  El factorial de 1 es: 1
<  El factorial de 2 es: 2
<  El factorial de 3 es: 6
<  El factorial de 4 es: 24
<  El factorial de 5 es: 120
<  El factorial de 6 es: 720
<  El factorial de 7 es: 5040
<  El factorial de 8 es: 40320
<  El factorial de 9 es: 362880
jp28
578a579,582
> BIG PROBLEM! No case defined for kind (
> BIG PROBLEM! No case defined for kind (
> BIG PROBLEM! No case defined for kind if
> BIG PROBLEM! No case defined for kind (
580,1190d583
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<     _f 4
<     _f1 4
<     _f2 4
<     _f3 4
<     _m 4
<     _r 4
<     _aux 4
<   endvariables
< 
<     aload _aux t0
<     iload 6 t1
<     stor t1 t0
<     load _aux t0
<     pushparam t0
<     aload _aux t0
<     pushparam t0
<     aload _f t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_fact
<     killparam
<     killparam
<     killparam
<     killparam
<     load _f t0
<     wrii t0
<     wrln
<     iload 8 t0
<     pushparam t0
<     aload _f1 t0
<     pushparam t0
<     aload _f2 t0
<     pushparam t0
<     aload _f3 t0
<     pushparam t0
<     iload 96 t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_F
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<     load _f1 t0
<     load _f3 t1
<     equi t0 t1 t0
<     fjmp t0 endif_1
<     load _f1 t0
<     wrii t0
<     wris "  "
<     load _f2 t0
<     wrii t0
<     wrln
<   etiq endif_1
<     iload 19 t0
<     pushparam t0
<     aload _m t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_trad
<     killparam
<     killparam
<     killparam
<     load _m t0
<     wrii t0
<     wrln
<     stop
< endprogram
< 
< subroutine program_fact_mult
<   parameters
<     _a
<     _b
<     _p
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _a t0
<     load t0 t0
<     iload 0 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     load _p t0
<     iload 0 t1
<     stor t1 t0
<     ujmp endif_1
<   etiq else_1
<     load _a t0
<     load t0 t0
<     iload 0 t1
<     grti t0 t1 t0
<     fjmp t0 endif_2
<     load _a t0
<     load _a t1
<     load t1 t1
<     iload 1 t2
<     subi t1 t2 t1
<     stor t1 t0
<     load _a t0
<     pushparam t0
<     load _b t0
<     pushparam t0
<     load _p t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_fact_mult
<     killparam
<     killparam
<     killparam
<     killparam
<     load _p t0
<     load _p t1
<     load t1 t1
<     load _b t2
<     load t2 t2
<     addi t1 t2 t1
<     stor t1 t0
<   etiq endif_2
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_fact_gfact
<   parameters
<     _y
<     _w
<     _n
<     _f
<     static_link
<   endparameters
< 
<   variables
<     _p 4
<     _aux 4
<   endvariables
< 
<     load _y t0
<     iload 0 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     load _f t0
<     load _w t1
<     stor t1 t0
<     ujmp endif_1
<   etiq else_1
<     load _y t0
<     iload 0 t1
<     grti t0 t1 t0
<     fjmp t0 endif_2
<     aload _aux t0
<     load _y t1
<     stor t1 t0
<     aload _y t0
<     pushparam t0
<     aload _w t0
<     pushparam t0
<     aload _p t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_fact_mult
<     killparam
<     killparam
<     killparam
<     killparam
<     aload _y t0
<     load _aux t1
<     stor t1 t0
<     load _y t0
<     iload 1 t1
<     subi t0 t1 t0
<     pushparam t0
<     load _p t0
<     pushparam t0
<     load _n t0
<     pushparam t0
<     load _f t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_fact_gfact
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<   etiq endif_2
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_fact
<   parameters
<     _n
<     _z
<     _f
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _n t0
<     pushparam t0
<     iload 1 t0
<     pushparam t0
<     load _z t0
<     load t0 t0
<     pushparam t0
<     load _f t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_fact_gfact
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<     retu
< endsubroutine
< 
< subroutine program_F_fibon
<   parameters
<     _n
<     _f
<     _f1
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _n t0
<     iload 1 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     load _f t0
<     iload 1 t1
<     stor t1 t0
<     load _f1 t0
<     iload 0 t1
<     stor t1 t0
<     ujmp endif_1
<   etiq else_1
<     load _n t0
<     iload 1 t1
<     grti t0 t1 t0
<     fjmp t0 endif_2
<     load _n t0
<     iload 1 t1
<     subi t0 t1 t0
<     pushparam t0
<     load _f t0
<     pushparam t0
<     load _f1 t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_F_fibon
<     killparam
<     killparam
<     killparam
<     killparam
<     load static_link t0
<     load t0 t0
<     addi t0 offset(program:_aux) t0
<     load _f t1
<     load t1 t1
<     stor t1 t0
<     load _f t0
<     load static_link t1
<     load t1 t1
<     addi t1 offset(program:_aux) t1
<     load t1 t1
<     load _f1 t2
<     load t2 t2
<     addi t1 t2 t1
<     stor t1 t0
<     load _f1 t0
<     load static_link t1
<     load t1 t1
<     addi t1 offset(program:_aux) t1
<     load t1 t1
<     stor t1 t0
<   etiq endif_2
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_F_fibon2
<   parameters
<     _n
<     _f
<     static_link
<   endparameters
< 
<   variables
<     _f1 4
<     _f2 4
<   endvariables
< 
<     load _n t0
<     iload 0 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     load _f t0
<     iload 0 t1
<     stor t1 t0
<     ujmp endif_1
<   etiq else_1
<     load _n t0
<     iload 1 t1
<     equi t0 t1 t0
<     fjmp t0 else_2
<     load _f t0
<     iload 1 t1
<     stor t1 t0
<     ujmp endif_2
<   etiq else_2
<     load _n t0
<     iload 1 t1
<     grti t0 t1 t0
<     fjmp t0 endif_3
<     load _n t0
<     iload 1 t1
<     subi t0 t1 t0
<     pushparam t0
<     aload _f1 t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_F_fibon2
<     killparam
<     killparam
<     killparam
<     load _n t0
<     iload 2 t1
<     subi t0 t1 t0
<     pushparam t0
<     aload _f2 t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_F_fibon2
<     killparam
<     killparam
<     killparam
<     load _f t0
<     load _f1 t1
<     load _f2 t2
<     addi t1 t2 t1
<     stor t1 t0
<   etiq endif_3
<   etiq endif_2
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_F
<   parameters
<     _n
<     _f1
<     _f2
<     _f3
<     _f4
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _n t0
<     pushparam t0
<     load _f1 t0
<     pushparam t0
<     load _f2 t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_F_fibon
<     killparam
<     killparam
<     killparam
<     killparam
<     load _n t0
<     pushparam t0
<     aload _f4 t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_F_fibon2
<     killparam
<     killparam
<     killparam
<     load _f3 t0
<     load _f4 t1
<     stor t1 t0
<     retu
< endsubroutine
< 
< subroutine program_trad_dividir
<   parameters
<     _a
<     _b
<     _c
<     _r
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _a t0
<     load _b t1
<     lesi t0 t1 t0
<     fjmp t0 else_1
<     load _c t0
<     iload 0 t1
<     stor t1 t0
<     load _r t0
<     load _a t1
<     stor t1 t0
<     ujmp endif_1
<   etiq else_1
<     load _a t0
<     pushparam t0
<     iload 2 t0
<     load _b t1
<     muli t0 t1 t0
<     pushparam t0
<     load _c t0
<     pushparam t0
<     load _r t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_trad_dividir
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<     load _r t0
<     load t0 t0
<     load _b t1
<     lesi t0 t1 t0
<     fjmp t0 else_2
<     load _c t0
<     iload 2 t1
<     load _c t2
<     load t2 t2
<     muli t1 t2 t1
<     stor t1 t0
<     ujmp endif_2
<   etiq else_2
<     load _c t0
<     iload 2 t1
<     load _c t2
<     load t2 t2
<     muli t1 t2 t1
<     iload 1 t2
<     addi t1 t2 t1
<     stor t1 t0
<     load _r t0
<     load _r t1
<     load t1 t1
<     load _b t2
<     subi t1 t2 t1
<     stor t1 t0
<   etiq endif_2
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_trad_gtrad
<   parameters
<     _u
<     _v
<     _w
<     _q
<     _m
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _w t0
<     iload 0 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     load _m t0
<     load _u t1
<     stor t1 t0
<     ujmp endif_1
<   etiq else_1
<     load _w t0
<     iload 0 t1
<     grti t0 t1 t0
<     fjmp t0 endif_2
<     load _w t0
<     pushparam t0
<     iload 2 t0
<     pushparam t0
<     aload _q t0
<     pushparam t0
<     load static_link t0
<     load t0 t0
<     addi t0 offset(program:_r) t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_trad_dividir
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<     load _u t0
<     load _v t1
<     load static_link t2
<     load t2 t2
<     addi t2 offset(program:_r) t2
<     load t2 t2
<     muli t1 t2 t1
<     addi t0 t1 t0
<     pushparam t0
<     load _v t0
<     iload 10 t1
<     muli t0 t1 t0
<     pushparam t0
<     load _q t0
<     pushparam t0
<     load _q t0
<     pushparam t0
<     load _m t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_trad_gtrad
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<   etiq endif_2
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_trad
<   parameters
<     _n
<     _m
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _m t0
<     iload 0 t1
<     stor t1 t0
<     load _m t0
<     load t0 t0
<     pushparam t0
<     load _m t0
<     load t0 t0
<     iload 1 t1
<     addi t0 t1 t0
<     pushparam t0
<     load _n t0
<     pushparam t0
<     load _m t0
<     load t0 t0
<     pushparam t0
<     load _m t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_trad_gtrad
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<     killparam
<     retu
< endsubroutine
< 
< Executing code:
< 720
< 21  13
< 10011
jp29
197a198,199
> BIG PROBLEM! No case defined for kind (
> BIG PROBLEM! No case defined for kind (
199,421d200
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     iload 0 t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_A2
<     killparam
<     killparam
<     iload 0 t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_A3
<     killparam
<     killparam
<     stop
< endprogram
< 
< subroutine program_A1
<   parameters
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     wris ""
<     wrln
<     retu
< endsubroutine
< 
< subroutine program_A2
<   parameters
<     _j
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _j t0
<     iload 0 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     wris "soy A2 llamado por main "
<     load static_link t0
<     pushparam t0
<     call program_A1
<     killparam
<     ujmp endif_1
<   etiq else_1
<     load _j t0
<     iload 3 t1
<     equi t0 t1 t0
<     fjmp t0 else_2
<     wris "soy A2 llamado por ABC "
<     load static_link t0
<     pushparam t0
<     call program_A1
<     killparam
<     ujmp endif_2
<   etiq else_2
<     wris "soy A2 llamado por AB1 "
<     load static_link t0
<     pushparam t0
<     call program_A1
<     killparam
<   etiq endif_2
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_A3_AB1_ABC
<   parameters
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     iload 3 t0
<     pushparam t0
<     load static_link t0
<     load t0 t0
<     load t0 t0
<     pushparam t0
<     call program_A2
<     killparam
<     killparam
<     iload 3 t0
<     pushparam t0
<     load static_link t0
<     load t0 t0
<     load t0 t0
<     pushparam t0
<     call program_A3
<     killparam
<     killparam
<     load static_link t0
<     load t0 t0
<     addi t0 offset(program_A3:_i) t0
<     load t0 t0
<     iload 1 t1
<     subi t0 t1 t0
<     pushparam t0
<     load static_link t0
<     load t0 t0
<     pushparam t0
<     call program_A3_AB1
<     killparam
<     killparam
<     retu
< endsubroutine
< 
< subroutine program_A3_AB1
<   parameters
<     _k
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _k t0
<     iload 1 t1
<     mini t1 t1
<     grti t0 t1 t0
<     fjmp t0 else_1
<     aload static_link t0
<     pushparam t0
<     call program_A3_AB1_ABC
<     killparam
<     ujmp endif_1
<   etiq else_1
<     iload 2 t0
<     pushparam t0
<     load static_link t0
<     load t0 t0
<     pushparam t0
<     call program_A2
<     killparam
<     killparam
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_A3_AB2
<   parameters
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load static_link t0
<     addi t0 offset(program_A3:_i) t0
<     load t0 t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_A3_AB1
<     killparam
<     killparam
<     retu
< endsubroutine
< 
< subroutine program_A3
<   parameters
<     _i
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _i t0
<     iload 0 t1
<     equi t0 t1 t0
<     fjmp t0 else_1
<     wris "soy A3 llamado por main "
<     load static_link t0
<     pushparam t0
<     call program_A1
<     killparam
<     aload static_link t0
<     pushparam t0
<     call program_A3_AB2
<     killparam
<     ujmp endif_1
<   etiq else_1
<     wris "soy A3 llamado por ABC "
<     load static_link t0
<     pushparam t0
<     call program_A1
<     killparam
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_A4
<   parameters
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     retu
< endsubroutine
< 
< Executing code:
< soy A2 llamado por main 
< soy A3 llamado por main 
< soy A2 llamado por ABC 
< soy A3 llamado por ABC 
< soy A2 llamado por AB1 
jp30
324a325
> BIG PROBLEM! No case defined for kind (
326,633d326
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<     _X 4
<     _Y 4
<   endvariables
< 
<     aload _X t0
<     iload 1 t1
<     stor t1 t0
<     aload _Y t0
<     iload 2 t1
<     stor t1 t0
<     load _X t0
<     pushparam t0
<     aload _Y t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_F2
<     killparam
<     killparam
<     killparam
<     load _Y t0
<     wrii t0
<     wrln
<     stop
< endprogram
< 
< subroutine program_F2_F21_F211
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     retu
< endsubroutine
< 
< subroutine program_F2_F21_F212
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     retu
< endsubroutine
< 
< subroutine program_F2_F21
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     retu
< endsubroutine
< 
< subroutine program_F2_F22_F221
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     retu
< endsubroutine
< 
< subroutine program_F2_F22_F222
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _Y t0
<     load _Y t1
<     load t1 t1
<     iload 1 t2
<     subi t1 t2 t1
<     stor t1 t0
<     iload 0 t0
<     load _Y t1
<     load t1 t1
<     lesi t0 t1 t0
<     fjmp t0 else_1
<     load _X t0
<     pushparam t0
<     load _Y t0
<     pushparam t0
<     load static_link t0
<     load t0 t0
<     pushparam t0
<     call program_F2_F22
<     killparam
<     killparam
<     killparam
<     ujmp endif_1
<   etiq else_1
<     aload _X t0
<     iload 1 t1
<     stor t1 t0
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_F2_F22
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     iload 0 t0
<     load _X t1
<     lesi t0 t1 t0
<     fjmp t0 else_1
<     load _X t0
<     iload 1 t1
<     subi t0 t1 t0
<     pushparam t0
<     load _Y t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_F2_F22_F222
<     killparam
<     killparam
<     killparam
<     ujmp endif_1
<   etiq else_1
<     aload _X t0
<     iload 2 t1
<     stor t1 t0
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_F2
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _X t0
<     pushparam t0
<     load _Y t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_F1
<     killparam
<     killparam
<     killparam
<     retu
< endsubroutine
< 
< subroutine program_F1_F11_F111
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     iload 111 t0
<     wrii t0
<     retu
< endsubroutine
< 
< subroutine program_F1_F11_F112
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     iload 112 t0
<     wrii t0
<     retu
< endsubroutine
< 
< subroutine program_F1_F11
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     iload 11 t0
<     wrii t0
<     load _X t0
<     pushparam t0
<     load _Y t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_F1_F12
<     killparam
<     killparam
<     killparam
<     retu
< endsubroutine
< 
< subroutine program_F1_F12_F121
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     iload 121 t0
<     wrii t0
<     retu
< endsubroutine
< 
< subroutine program_F1_F12_F122
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     iload 122 t0
<     wrii t0
<     retu
< endsubroutine
< 
< subroutine program_F1_F12
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     iload 12 t0
<     wrii t0
<     retu
< endsubroutine
< 
< subroutine program_F1
<   parameters
<     _X
<     _Y
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _X t0
<     pushparam t0
<     load _Y t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_F1_F11
<     killparam
<     killparam
<     killparam
<     retu
< endsubroutine
< 
< Executing code:
< 11122
jp31
142a143
> BIG PROBLEM! No case defined for kind while
144,287d144
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<     _n 4
<   endvariables
< 
<     aload _n t0
<     iload 1 t1
<     stor t1 t0
<   etiq while_1
<     load _n t0
<     iload 10 t1
<     lesi t0 t1 t0
<     fjmp t0 endwhile_1
<     wris "Fibonacci("
<     load _n t0
<     wrii t0
<     wris ")="
<     pushparam 0
<     load _n t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_fibon
<     killparam
<     killparam
<     popparam t0
<     wrii t0
<     wrln
<     aload _n t0
<     load _n t1
<     iload 1 t2
<     addi t1 t2 t1
<     stor t1 t0
<     ujmp while_1
<   etiq endwhile_1
<     stop
< endprogram
< 
< subroutine program_fibon_recfibon
<   parameters
<     _n
<     _n1
<     _n2
<     static_link
<   endparameters
< 
<   variables
<     _aux 4
<   endvariables
< 
<     load _n t0
<     iload 0 t1
<     equi t0 t1 t0
<     load _n t1
<     iload 1 t2
<     equi t1 t2 t1
<     loor t0 t1 t0
<     fjmp t0 else_1
<     load _n1 t0
<     iload 1 t1
<     stor t1 t0
<     load _n2 t0
<     iload 1 t1
<     stor t1 t0
<     ujmp endif_1
<   etiq else_1
<     load _n t0
<     iload 1 t1
<     subi t0 t1 t0
<     pushparam t0
<     load _n1 t0
<     pushparam t0
<     load _n2 t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_fibon_recfibon
<     killparam
<     killparam
<     killparam
<     killparam
<     aload _aux t0
<     load _n1 t1
<     load t1 t1
<     stor t1 t0
<     load _n1 t0
<     load _n2 t1
<     load t1 t1
<     stor t1 t0
<     load _n2 t0
<     load _aux t1
<     load _n2 t2
<     load t2 t2
<     addi t1 t2 t1
<     stor t1 t0
<   etiq endif_1
<     retu
< endsubroutine
< 
< subroutine program_fibon
<   parameters
<     returnvalue
<     _n
<     static_link
<   endparameters
< 
<   variables
<     _retvalue 4
<     _n1 4
<     _n2 4
<   endvariables
< 
<     load _n t0
<     pushparam t0
<     aload _n1 t0
<     pushparam t0
<     aload _n2 t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_fibon_recfibon
<     killparam
<     killparam
<     killparam
<     killparam
<     load _n2 t0
<     stor t0 returnvalue
<     retu
< endsubroutine
< 
< Executing code:
< Fibonacci(1)=1
< Fibonacci(2)=2
< Fibonacci(3)=3
< Fibonacci(4)=5
< Fibonacci(5)=8
< Fibonacci(6)=13
< Fibonacci(7)=21
< Fibonacci(8)=34
< Fibonacci(9)=55
jp32
267,526c267,277
< Generating code:
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<     _S 44
<   endvariables
< 
<     aload _S t0
<     addi t0 4 t0
<     iload 3 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     iload 1 t1
<     stor t1 t0
<     aload _S t0
<     addi t0 4 t0
<     iload 4 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     iload 2 t1
<     stor t1 t0
<     aload _S t0
<     pushparam t0
<     aload static_link t0
<     pushparam t0
<     call program_P2
<     killparam
<     killparam
<     aload _S t0
<     addi t0 0 t0
<     load t0 t0
<     wrii t0
<     wrln
<     aload _S t0
<     addi t0 4 t0
<     iload 3 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     load t0 t0
<     wrii t0
<     wrln
<     aload _S t0
<     addi t0 4 t0
<     iload 4 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     load t0 t0
<     wrii t0
<     wrln
<     aload _S t0
<     addi t0 4 t0
<     iload 5 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     load t0 t0
<     wrii t0
<     wrln
<     aload _S t0
<     addi t0 4 t0
<     iload 6 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     load t0 t0
<     wrii t0
<     wrln
<     stop
< endprogram
< 
< subroutine program_P1
<   parameters
<     _A
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _A t0
<     iload 3 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     iload 5 t1
<     stor t1 t0
<     retu
< endsubroutine
< 
< subroutine program_P2
<   parameters
<     _S2
<     static_link
<   endparameters
< 
<   variables
<     aux_space 80
<   endvariables
< 
<     load _S2 t0
<     addi t0 4 t0
<     aload aux_space t1
<     addi t1 0 t1
<     pushparam t1
<     load _S2 t2
<     addi t2 4 t2
<     pushparam t2
<     load static_link t2
<     pushparam t2
<     call program_F1
<     killparam
<     killparam
<     killparam
<     copy t1 t0 40
<     load _S2 t0
<     addi t0 4 t0
<     aload aux_space t1
<     addi t1 0 t1
<     pushparam t1
<     load _S2 t3
<     addi t3 4 t3
<     aload aux_space t2
<     addi t2 40 t2
<     copy t3 t2 40
<     pushparam t2
<     load static_link t2
<     pushparam t2
<     call program_F2
<     killparam
<     killparam
<     killparam
<     copy t1 t0 40
<     load _S2 t0
<     addi t0 0 t0
<     iload 3 t1
<     stor t1 t0
<     load _S2 t0
<     addi t0 4 t0
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_P1
<     killparam
<     killparam
<     load _S2 t1
<     addi t1 4 t1
<     aload aux_space t0
<     addi t0 0 t0
<     copy t1 t0 40
<     pushparam t0
<     load static_link t0
<     pushparam t0
<     call program_P3
<     killparam
<     killparam
<     retu
< endsubroutine
< 
< subroutine program_P3
<   parameters
<     _A2
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _A2 t0
<     iload 4 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     iload 5 t1
<     stor t1 t0
<     retu
< endsubroutine
< 
< subroutine program_F1
<   parameters
<     returnvalue
<     _A
<     static_link
<   endparameters
< 
<   variables
<     _B 40
<   endvariables
< 
<     aload _B t0
<     load _A t1
<     copy t1 t0 40
<     aload _B t0
<     iload 5 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     aload _B t1
<     iload 3 t2
<     muli t2 4 t2
<     addi t1 t2 t1
<     load t1 t1
<     aload _B t2
<     iload 4 t3
<     muli t3 4 t3
<     addi t2 t3 t2
<     load t2 t2
<     addi t1 t2 t1
<     stor t1 t0
<     aload _B t1
<     load returnvalue t0
<     copy t1 t0 40
<     retu
< endsubroutine
< 
< subroutine program_F2
<   parameters
<     returnvalue
<     _A
<     static_link
<   endparameters
< 
<   variables
<     _B 40
<   endvariables
< 
<     aload _B t0
<     load _A t1
<     copy t1 t0 40
<     aload _B t0
<     iload 6 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     aload _B t1
<     iload 3 t2
<     muli t2 4 t2
<     addi t1 t2 t1
<     load t1 t1
<     aload _B t2
<     iload 4 t3
<     muli t3 4 t3
<     addi t2 t3 t2
<     load t2 t2
<     addi t1 t2 t1
<     aload _B t2
<     iload 5 t3
<     muli t3 4 t3
<     addi t2 t3 t2
<     load t2 t2
<     addi t1 t2 t1
<     stor t1 t0
<     aload _B t1
<     load returnvalue t0
<     copy t1 t0 40
<     retu
< endsubroutine
< 
< Executing code:
< 3
< 5
< 2
< 3
< 6
---
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind [
> L. 37: Left expression of assignment is not referenceable.
> BIG PROBLEM! No case defined for kind [
> L. 38: Left expression of assignment is not referenceable.
> BIG PROBLEM! No case defined for kind (
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind [
> BIG PROBLEM! No case defined for kind [
> There are errors: no code generated
jp33
133,261c133,140
< Generating code:
< program
<   parameters
<     static_link
<   endparameters
< 
<   variables
<     _S 88
<     _X 4
<     aux_space 88
<   endvariables
< 
<     aload _X t0
<     iload 1 t1
<     mini t1 t1
<     stor t1 t0
<     aload _S t0
<     iload 0 t1
<     muli t1 44 t1
<     addi t0 t1 t0
<     addi t0 4 t0
<     iload 0 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     iload 3 t1
<     stor t1 t0
<     aload _S t0
<     iload 1 t1
<     muli t1 44 t1
<     addi t0 t1 t0
<     addi t0 4 t0
<     iload 1 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     iload 5 t1
<     stor t1 t0
<     aload _X t0
<     pushparam 0
<     aload aux_space t1
<     addi t1 0 t1
<     pushparam t1
<     aload static_link t2
<     pushparam t2
<     call program_F
<     killparam
<     killparam
<     addi t1 4 t1
<     pushparam t1
<     aload aux_space t1
<     addi t1 44 t1
<     pushparam t1
<     aload static_link t2
<     pushparam t2
<     call program_F
<     killparam
<     killparam
<     addi t1 4 t1
<     pushparam t1
<     aload static_link t1
<     pushparam t1
<     call program_G
<     killparam
<     killparam
<     killparam
<     popparam t1
<     stor t1 t0
<     load _X t0
<     wrii t0
<     wrln
<     stop
< endprogram
< 
< subroutine program_F
<   parameters
<     returnvalue
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load static_link t0
<     addi t0 offset(program:_X) t0
<     load static_link t1
<     addi t1 offset(program:_X) t1
<     load t1 t1
<     iload 1 t2
<     addi t1 t2 t1
<     stor t1 t0
<     load static_link t1
<     addi t1 offset(program:_S) t1
<     load static_link t2
<     addi t2 offset(program:_X) t2
<     load t2 t2
<     muli t2 44 t2
<     addi t1 t2 t1
<     load returnvalue t0
<     copy t1 t0 44
<     retu
< endsubroutine
< 
< subroutine program_G
<   parameters
<     returnvalue
<     _A0
<     _A1
<     static_link
<   endparameters
< 
<   variables
<   endvariables
< 
<     load _A0 t0
<     iload 0 t1
<     muli t1 4 t1
<     addi t0 t1 t0
<     load t0 t0
<     load _A1 t1
<     iload 1 t2
<     muli t2 4 t2
<     addi t1 t2 t1
<     load t1 t1
<     addi t0 t1 t0
<     stor t0 returnvalue
<     retu
< endsubroutine
< 
< Executing code:
< 8
---
> BIG PROBLEM! No case defined for kind array
> BIG PROBLEM! No case defined for kind -
> BIG PROBLEM! No case defined for kind [
> L. 19: Left expression of assignment is not referenceable.
> BIG PROBLEM! No case defined for kind [
> L. 20: Left expression of assignment is not referenceable.
> BIG PROBLEM! No case defined for kind (
> There are errors: no code generated
